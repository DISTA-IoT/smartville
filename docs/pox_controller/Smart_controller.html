<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8"> <!-- Sets character encoding to UTF-8 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Ensures responsive design -->
    <title>Smartville Documentation</title> <!-- Title displayed in the browser tab -->
    
    <!-- Link to an external CSS file for styling -->
    <link rel="stylesheet" href="../style.css">
    <!-- Link to an external JavaScript file that loads after HTML content -->
    <script src="../script.js" defer></script>
</head>
<body>

    
    <!-- Sidebar for navigation -->
    <div class="sidebar">
        <!-- Navigation links to various documentation sections -->
        <a href="../main_content/Intro.html">Introduction</a>
        <a href="../main_content/Installation.html">Installation</a>
        <a href="../main_content/Usage.html">Usage</a>
        <a href="../main_content/Background.html">Background</a>
        <a href="../main_content/Docker.html">Docker Containers</a>
        <a href="../main_content/platform.html">Grafana, Kafka, Prometheus</a>
        <a href="../main_content/PN.html">Prototypical Networks</a>
        <a href="../main_content/License.html">License</a>
        <a href="../main_content/Citation.html">Citation</a>
        
        <!-- Link to toggle visibility of subcategories under 'Code' -->
        <a href="javascript:void(0)" onclick="toggleSubcategories()">Code</a>
        
        <!-- Subcategories for 'Code', initially hidden -->
        <div id="codeSubcategories" style="display:none;">
            <!-- Subcategory for 'pox_controller' -->
            <div id="pox_controller" class="subcategory">
                <!-- Link to toggle visibility of 'pox_controller' subcategories -->
                <a href="javascript:void(0)" onclick="togglePoxControllerSubcategories()" style="padding-left:20px;">pox_controller</a>
                
                <!-- Subcategories within 'pox_controller' -->
                <div id="poxControllerSubcategories" style="display:none;">
                    <div id="neural_models" class="subcategory">
                        <a href="../pox_controller/Neural_models.html" style="padding-left:40px;">Neural Models</a>
                    </div>
                    <div id="controller_brain" class="subcategory">
                        <a href="../pox_controller/Controller_brain.html" style="padding-left:40px;">Controller Brain</a>
                    </div>
                    <div id="graph_generator" class="subcategory">
                        <a href="../pox_controller/Graph_generator.html" style="padding-left:40px;">Graph Generator</a>
                    </div>
                    <div id="consumer_thread" class="subcategory">
                        <a href="../pox_controller/Consumer_thread.html" style="padding-left:40px;">Consumer Thread</a>
                    </div>
                    <div id="smart_controller" class="subcategory">
                        <a href="../pox_controller/Smart_controller.html" style="padding-left:40px;">Smart Controller</a>
                    </div>
                    <div id="ai" class="subcategory">
                        <a href="../pox_controller/ai.html" style="padding-left:40px;">Ai</a>
                    </div>
                    <div id="curricula" class="subcategory">
                        <a href="../pox_controller/Curricula.html" style="padding-left:40px;">Curricula</a>
                    </div>
                    <div id="dash_generator" class="subcategory">
                        <a href="../pox_controller/Dash_generator.html" style="padding-left:40px;">Dash Generator</a>
                    </div>
                    <div id="arp_entry" class="subcategory">
                        <a href="../pox_controller/Arp_entry.html" style="padding-left:40px;">Arp Entry</a>
                    </div>
                    <div id="flow" class="subcategory">
                        <a href="../pox_controller/Flow.html" style="padding-left:40px;">Flow</a>
                    </div>
                    <div id="flow_logger" class="subcategory">
                        <a href="../pox_controller/Flow_logger.html" style="padding-left:40px;">Flow Logger</a>
                    </div>
                    <div id="grafana_prometheus" class="subcategory">
                        <a href="../pox_controller/Grafana_prometheus.html" style="padding-left:40px;">Grafana-prometheus</a>
                    </div>
                    <div id="metrics_logger" class="subcategory">
                        <a href="../pox_controller/Metrics_logger.html" style="padding-left:40px;">Metrics Logger</a>
                    </div>
                    <div id="replay_buffer" class="subcategory">
                        <a href="../pox_controller/Replay_buffer.html" style="padding-left:40px;">Replay Buffer</a>
                    </div>
                    <div id="prometheus_server" class="subcategory">
                        <a href="../pox_controller/Prometheus_server.html" style="padding-left:40px;">Prometheus Server</a>
                    </div>
                    <div id="wandb_tracker" class="subcategory">
                        <a href="../pox_controller/Wandb_tracker.html" style="padding-left:40px;">Wandb Tracker</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="main-content">
        <div class="header">
            <h1><a href="../index.html" style="text-decoration: none;">Smartville</h1></a>
            <p>This is the official SmartVille repository</p>
            <p>Smartville is an open-source testbed based on GNS3, Pytorch, and Docker for training and testing online
                intrusion detection systems based on machine learning.</p>
            <p>Feel free to contribute!</p>
            <p>The related paper <em>"SmartVille: an open-source SDN online-intrusion detection testbed"</em> is under
                review. Stay tuned!</p>
        </div>
        
        
        
        
        <div id="smart_controller" class="content">
            <h2>Smart L3 Switch</h2>
            <p>This file defines a Smart Layer 3 (L3) switch as part of the "Smartville" project. It extends the
                functionality of a traditional L3 learning switch by integrating intelligent mechanisms to manage
                network traffic. The key features of this switch include handling ARP (Address Resolution Protocol) and
                IP packets, maintaining a table that maps IP addresses to MAC addresses and switch ports, and optimizing
                network flow using various techniques.</p>

            <h3>Class: SmartSwitch</h3>
            <p>The <code>SmartSwitch</code> class is responsible for managing network traffic by learning associations
                between IP addresses, MAC addresses, and switch ports. It also handles ARP and IP packets to ensure
                efficient traffic routing.</p>

            <h4>Method: __init__</h4>
            <p>This constructor initializes the <code>SmartSwitch</code> with parameters such as flow timeout, ARP
                timeout, and buffering configurations.</p>
            <p><strong>Description:</strong> The <code>__init__</code> method sets up the switch with essential
                parameters and initializes timers for expiration handling and smart checks. It also prepares tables and
                dictionaries to manage ARP entries and unprocessed flows.</p>
            <pre><code>
        def __init__ (
            self, 
            flow_logger, 
            metrics_logger, 
            brain,
            use_node_feats: bool = False,
            flow_idle_timeout: int = 10,
            arp_timeout: int = 120,
            max_buffered_packets:int = 5,
            max_buffering_secs:int = 5,
            arp_req_exp_secs:int = 4,
            inference_freq_secs:int = 5):
    
            self.flow_idle_timeout = flow_idle_timeout
            self.arp_timeout = arp_timeout
            self.max_buffered_packets = max_buffered_packets
            self.max_buffering_secs = max_buffering_secs
            self.arp_req_exp_secs = arp_req_exp_secs
    
            self.use_node_feats = use_node_feats
            self.recently_sent_ARPs = {}
            self.unprocessed_flows = {}
            self.arpTables = {}
    
            self.brain = brain
    
            self._expire_timer = Timer(5, self._handle_expiration, recurring=True)
            self.smart_check_timer = Timer(inference_freq_secs, self.smart_check, recurring=True)
    
            self.flow_logger = flow_logger
            self.metrics_logger = metrics_logger
    
            core.listen_to_dependencies(self)
        </code></pre>

            <h4>Method: smart_check</h4>
            <p>This method periodically classifies network flows using machine learning models.</p>
            <p><strong>Description:</strong> The <code>smart_check</code> method calls the classifier in the controller
                brain to analyze and categorize network traffic, potentially using node features and flow data.</p>
            <pre><code>
        def smart_check(self):
            if self.use_node_feats:
                self.brain.classify_duet(
                    flows=list(self.flow_logger.flows_dict.values()),
                    node_feats=self.metrics_logger.metrics_dict)
            else:
                self.brain.classify_duet(
                    flows=list(self.flow_logger.flows_dict.values()))
        </code></pre>

            <h4>Method: _handle_expiration</h4>
            <p>This method removes outdated packets from the buffer and instructs the switch to drop them.</p>
            <p><strong>Description:</strong> The <code>_handle_expiration</code> method checks the expiration of
                buffered packets. If a packet is expired, it sends a message to the switch to drop that packet.</p>
            <pre><code>
        def _handle_expiration(self):
            to_delete_flows = []
    
            for flow_metadata, packet_metadata_list in self.unprocessed_flows.items():
                switch_id, _ = flow_metadata
    
                if len(packet_metadata_list) == 0:
                    to_delete_flows.append(flow_metadata)
                else: 
                    for packet_metadata in list(packet_metadata_list):
                        expires_at, packet_id, in_port, _ = packet_metadata
    
                        if expires_at < time.time():
                            packet_metadata_list.remove(packet_metadata)
                            po = of.ofp_packet_out(buffer_id=packet_id, in_port=in_port)
                            core.openflow.sendToDPID(switch_id, po)
    
            for flow_metadata in to_delete_flows:
                del self.unprocessed_flows[flow_metadata]
        </code></pre>

            <h4>Method: _send_unprocessed_flows</h4>
            <p>This method attempts to resend buffered packets once the destination is known.</p>
            <p><strong>Description:</strong> The <code>_send_unprocessed_flows</code> method checks if the destination
                IP address and MAC address have been resolved. If so, it sends the buffered packets to their
                destinations.</p>
            <pre><code>
        def _send_unprocessed_flows(self, switch_id, port, dest_mac_addr, dest_ip_addr):
            query_tuple = (switch_id, dest_ip_addr)
            if query_tuple in self.unprocessed_flows.keys():
                bucket = self.unprocessed_flows[query_tuple]    
                del self.unprocessed_flows[query_tuple]
    
                log.debug(f"Sending {len(bucket)} buffered packets to {dest_ip_addr}")
    
                for _, packet_id, in_port, _ in bucket:
                    po = of.ofp_packet_out(buffer_id=packet_id, in_port=in_port)
                    po.actions.append(of.ofp_action_dl_addr.set_dst(dest_mac_addr))
                    po.actions.append(of.ofp_action_output(port=port))
                    core.openflow.sendToDPID(switch_id, po)
        </code></pre>

            <h4>Method: delete_ip_flow_matching_rules</h4>
            <p>This method deletes flow rules that match a specific destination IP address.</p>
            <p><strong>Description:</strong> The <code>delete_ip_flow_matching_rules</code> method removes flow rules
                from the switch that match a given destination IP address to prevent outdated routing.</p>
            <pre><code>
        def delete_ip_flow_matching_rules(self, dest_ip, connection):
            switch_id = connection.dpid
    
            msg = of.ofp_flow_mod(command=of.OFPFC_DELETE)
            msg.match.nw_dst = dest_ip
            msg.match.dl_type = ethernet.IP_TYPE
            connection.send(msg)
    
            log.info(f"Switch {switch_id} will delete flow rules matching nw_dst={dest_ip}")
        </code></pre>

            <h4>Method: learn_or_update_arp_table</h4>
            <p>This method learns or updates ARP table entries for a given IP address, MAC address, and port.</p>
            <p><strong>Description:</strong> The <code>learn_or_update_arp_table</code> method updates the ARP table
                with new information about the network, including IP-to-MAC mappings and switch ports. It also deletes
                any flow rules that are now outdated.</p>
            <pre><code>
        def learn_or_update_arp_table(
            self, 
            ip_addr,
            mac_addr,
            port, 
            connection):
    
            switch_id = connection.dpid 
    
            if ip_addr in self.arpTables[switch_id] and \
                self.arpTables[switch_id][ip_addr] != (port, mac_addr):
    
                self.delete_ip_flow_matching_rules(
                    dest_ip=ip_addr,
                    connection=connection)
    
            self.arpTables[switch_id][ip_addr] = Entry(
                port=port, 
                mac=mac_addr, 
                ARP_TIMEOUT=self.arp_timeout)
    
            log.debug(f"Entry added/updated to switch {switch_id}'s internal arp table: (port:{port} ip:{ip_addr})")
        </code></pre>

            <h4>Method: add_ip_to_ip_flow_matching_rule</h4>
            <p>This method adds a flow rule for an IP packet, specifying how it should be routed.</p>
            <p><strong>Description:</strong> The <code>add_ip_to_ip_flow_matching_rule</code> method creates and
                installs a flow rule in the switch that dictates how packets matching specific IP addresses should be
                routed.</p>
            <pre><code>
        def add_ip_to_ip_flow_matching_rule(
            self, 
            switch_id,
            source_ip_addr, 
            dest_ip_addr, 
            dest_mac_addr, 
            outgoing_port,
            connection,
            packet_id,
            type):
    
            actions = []
            actions.append(of.ofp_action_dl_addr.set_dst(dest_mac_addr))
            actions.append(of.ofp_action_output(port=outgoing_port))
    
            match = of.ofp_match(
                dl_type=type, 
                nw_src=source_ip_addr,
                nw_dst=dest_ip_addr)
    
            msg = of.ofp_flow_mod(command=of.OFPFC_ADD,
                                  idle_timeout=self.flow_idle_timeout,
                                  hard_timeout=of.OFP_FLOW_PERMANENT,
                                  buffer_id=packet_id,
                                  actions=actions,
                                  match=match)
    
            connection.send(msg.pack())
    
            log.debug(f"Added new flow rule to:{switch_id} match: {match} actions: {actions}")
        </code></pre>

            <h4>Method: build_and_send_ARP_request</h4>
            <p>This method sends an ARP request to discover the MAC address associated with an IP address.</p>
            <p><strong>Description:</strong> The <code>build_and_send_ARP_request</code> method constructs an ARP
                request and broadcasts it to discover the MAC address for a given IP address.</p>
            <pre><code>
        def build_and_send_ARP_request(
            self, 
            switch_id, 
            incomming_port,
            source_mac_addr,
            source_ip_addr,
            dest_ip_addr,
            connection):
    
            request = arp()
            request.hwtype = request.HW_TYPE_ETHERNET
            request.prototype = request.PROTO_TYPE_IP
            request.hwlen = 6
            request.protolen = request.protolen
            request.opcode = request.REQUEST
            request.hwdst = ETHER_BROADCAST
            request.protodst = dest_ip_addr
            request.hwsrc = source_mac_addr
            request.protosrc = source_ip_addr
            e = ethernet(type=ethernet.ARP_TYPE, src=source_mac_addr,
                          dst=ETHER_BROADCAST)
            e.set_payload(request)
    
            log.debug(f"{switch_id}'s port {incomming_port} ARPing for {dest_ip_addr} on behalf of {source_ip_addr}")
    
            msg = of.ofp_packet_out()
            msg.data = e.pack()
            msg.actions.append(of.ofp_action_output(port=of.OFPP_FLOOD))
            msg.in_port = incomming_port
            connection.send(msg)
        </code></pre>

            <h4>Method: add_unprocessed_packet</h4>
            <p>This method buffers a packet when its destination is unknown, to be sent later.</p>
            <p><strong>Description:</strong> The <code>add_unprocessed_packet</code> method stores packets in a buffer
                when the destination MAC address is not yet known, allowing them to be forwarded once the destination is
                resolved.</p>
            <pre><code>
        def add_unprocessed_packet(self, switch_id, dst_ip, port, src_ip, buffer_id):
            tuple_key = (switch_id, dst_ip)
            if tuple_key not in self.unprocessed_flows: 
                self.unprocessed_flows[tuple_key] = []
            packet_metadata_list = self.unprocessed_flows[tuple_key]
            packet_metadata = (time.time() + self.max_buffering_secs, 
                               buffer_id, 
                               port,
                               src_ip)
            packet_metadata_list.append(packet_metadata)
            while len(packet_metadata_list) > self.max_buffered_packets: 
                del packet_metadata_list[0]
        </code></pre>

            <h4>Method: handle_unknown_ip_packet</h4>
            <p>This method manages IP packets where the destination MAC address is unknown.</p>
            <p><strong>Description:</strong> The <code>handle_unknown_ip_packet</code> method buffers the packet and
                initiates an ARP request to determine the destination MAC address.</p>
            <pre><code>
        def handle_unknown_ip_packet(self, switch_id, incomming_port, packet_in_event):
            packet = packet_in_event.parsed
            source_mac_addr = packet.src
            source_ip_addr = packet.next.srcip
            dest_ip_addr = packet.next.dstip
    
            self.add_unprocessed_packet(switch_id=switch_id,
                                        dst_ip=dest_ip_addr,
                                        port=incomming_port,
                                        src_ip=source_ip_addr,
                                        buffer_id=packet_in_event.ofp.buffer_id)
    
            self.recently_sent_ARPs = {k:v for k, v in self.recently_sent_ARPs.items() if v > time.time()}
    
            if (switch_id, dest_ip_addr) in self.recently_sent_ARPs:
                return
    
            self.recently_sent_ARPs[(switch_id, dest_ip_addr)] = time.time() + self.arp_req_exp_secs
    
            self.build_and_send_ARP_request(
                switch_id, 
                incomming_port,
                source_mac_addr,
                source_ip_addr,
                dest_ip_addr,
                connection=packet_in_event.connection)
        </code></pre>

            <h4>Method: try_creating_flow_rule</h4>
            <p>This method attempts to create a flow rule for a given IP packet, ensuring correct routing.</p>
            <p><strong>Description:</strong> The <code>try_creating_flow_rule</code> method checks if the destination IP
                is known and creates a flow rule accordingly. If the destination is unknown, it handles the packet as an
                unknown IP packet.</p>
            <pre><code>
        def try_creating_flow_rule(self, switch_id, incomming_port, packet_in_event):
            packet = packet_in_event.parsed
            source_ip_addr = packet.next.srcip
            dest_ip_addr = packet.next.dstip
    
            if dest_ip_addr in self.arpTables[switch_id]:
                outgoing_port = self.arpTables[switch_id][dest_ip_addr].port
    
                if outgoing_port != incomming_port:
                    dest_mac_addr = self.arpTables[switch_id][dest_ip_addr].mac
                    self.add_ip_to_ip_flow_matching_rule(
                                        switch_id,
                                        source_ip_addr, 
                                        dest_ip_addr, 
                                        dest_mac_addr, 
                                        outgoing_port,
                                        connection=packet_in_event.connection,
                                        packet_id=packet_in_event.ofp.buffer_id,
                                        type=packet.type)
    
            else:
                self.handle_unknown_ip_packet(switch_id, incomming_port, packet_in_event)
        </code></pre>

            <h4>Method: handle_ipv4_packet_in</h4>
            <p>This method processes incoming IPv4 packets and manages their routing.</p>
            <p><strong>Description:</strong> The <code>handle_ipv4_packet_in</code> method updates the ARP table, sends
                any buffered packets, and creates new flow rules if necessary.</p>
            <pre><code>
        def handle_ipv4_packet_in(self, switch_id, incomming_port, packet_in_event):
            packet = packet_in_event.parsed
    
            log.debug("IPV4 DETECTED - SWITCH: %i ON PORT: %i IP SENDER: %s IP RECEIVER %s", 
                      switch_id,
                      incomming_port,
                      packet.next.srcip,
                      packet.next.dstip)
    
            create_flow_rule = self.flow_logger.cache_unprocessed_packets(
               src_ip=packet.next.srcip,
               dst_ip=packet.next.dstip,
               packet=packet)
    
            self._send_unprocessed_flows(
               switch_id, 
               incomming_port, 
               dest_mac_addr=packet.src,
               dest_ip_addr=packet.next.srcip)
    
            self.learn_or_update_arp_table(ip_addr=packet.next.srcip,
                                           mac_addr=packet.src,
                                           port=incomming_port, 
                                           connection=packet_in_event.connection)
    
            if create_flow_rule:
                self.try_creating_flow_rule(switch_id, 
                                            incomming_port, 
                                            packet_in_event)
        </code></pre>

            <h4>Method: send_arp_response</h4>
            <p>This method sends an ARP response back to the requesting device.</p>
            <p><strong>Description:</strong> The <code>send_arp_response</code> method constructs and sends an ARP
                response based on the information in the ARP table.</p>
            <pre><code>
        def send_arp_response(self, connection, l2_packet, l3_packet, outgoing_port):
            switch_id = connection.dpid
    
            arp_response = arp()
            arp_response.hwtype = l3_packet.hwtype
            arp_response.prototype = l3_packet.prototype
            arp_response.hwlen = l3_packet.hwlen
            arp_response.protolen = l3_packet.protolen
            arp_response.opcode = arp.REPLY
            arp_response.hwdst = l3_packet.hwsrc
            arp_response.protodst = l3_packet.protosrc
            arp_response.protosrc = l3_packet.protodst
            arp_response.hwsrc = self.arpTables[switch_id][l3_packet.protodst].mac
    
            ethernet_wrapper = ethernet(type=l2_packet.type, 
                         src=dpid_to_mac(switch_id),
                          dst=l3_packet.hwsrc)
    
            ethernet_wrapper.set_payload(arp_response)
    
            log.debug(f"ARP ANSWER from switch {switch_id}: ADDRESS:{arp_response.protosrc}")
    
            msg = of.ofp_packet_out()
            msg.data = ethernet_wrapper.pack()
            msg.actions.append(of.ofp_action_output(port=of.OFPP_IN_PORT))
            msg.in_port = outgoing_port
            connection.send(msg)
        </code></pre>

            <h4>Method: handle_arp_packet_in</h4>
            <p>This method processes incoming ARP packets, handling requests and replies.</p>
            <p><strong>Description:</strong> The <code>handle_arp_packet_in</code> method updates the ARP table with the
                information from the ARP packet and either responds to the ARP request or floods the packet.</p>
            <pre><code>
        def handle_arp_packet_in(self, switch_id, incomming_port, packet_in_event):
            packet = packet_in_event.parsed
            inner_packet = packet.next
    
            arp_operation = ''
            if inner_packet.opcode == arp.REQUEST: arp_operation = 'request'
            elif inner_packet.opcode == arp.REPLY: arp_operation = 'reply'
            else: arp_operation = 'op_' + str(inner_packet.opcode)
    
            log.debug(f"ARP {arp_operation} received: SWITCH: {switch_id} IN PORT:{incomming_port} ARP FROM: {inner_packet.protosrc} TO {inner_packet.protodst}")
    
            if inner_packet.prototype == arp.PROTO_TYPE_IP and \
                inner_packet.hwtype == arp.HW_TYPE_ETHERNET and \
                  inner_packet.protosrc != 0:
    
                self.learn_or_update_arp_table(ip_addr=inner_packet.protosrc,
                                               mac_addr=packet.src,
                                               port=incomming_port, 
                                               connection=packet_in_event.connection)
    
                self._send_unprocessed_flows(
                    switch_id, 
                    incomming_port, 
                    dest_mac_addr=packet.src,
                    dest_ip_addr=inner_packet.protosrc)
    
                if inner_packet.opcode == arp.REQUEST and \
                    inner_packet.protodst in self.arpTables[switch_id] and \
                      not self.arpTables[switch_id][inner_packet.protodst].isExpired():
    
                    self.send_arp_response(connection=packet_in_event.connection,
                                           l2_packet=packet,
                                           l3_packet=inner_packet,
                                           outgoing_port=incomming_port)
    
                    return
    
            log.debug(f"Flooding ARP {arp_operation} Switch: {switch_id} IN_PORT: {incomming_port} from:{inner_packet.protosrc} to:{inner_packet.protodst}")
    
            msg = of.ofp_packet_out(
               in_port=incomming_port, 
               data=packet_in_event.ofp,
               action=of.ofp_action_output(port=of.OFPP_FLOOD))
    
            packet_in_event.connection.send(msg)
        </code></pre>

            <h4>Method: _handle_openflow_PacketIn</h4>
            <p>This method processes incoming packets from the OpenFlow switch.</p>
            <p><strong>Description:</strong> The <code>_handle_openflow_PacketIn</code> method determines the type of
                packet (IPv4, ARP, etc.) and invokes the appropriate handler method to process it.</p>
            <pre><code>
        def _handle_openflow_PacketIn(self, event):
            switch_id = event.connection.dpid
            incomming_port = event.port
            packet = event.parsed
    
            if not packet.parsed:
                log.warning(f"switch {switch_id}, port {incomming_port}: ignoring unparsed packet")
                return
    
            if switch_id not in self.arpTables:
                log.info(f"New switch detected - creating empty flow table with id {switch_id}")
                self.arpTables[switch_id] = {}
    
            if packet.type == ethernet.LLDP_TYPE:
                return
    
            if isinstance(packet.next, ipv4):
                self.handle_ipv4_packet_in(
                  switch_id=switch_id,
                  incomming_port=incomming_port,
                  packet_in_event=event)
    
            elif isinstance(packet.next, arp):
                self.handle_arp_packet_in(
                  switch_id=switch_id,
                  incomming_port=incomming_port,
                  packet_in_event=event)
        </code></pre>
        </div>
    </div>   
        
        

</body>

</html>
   