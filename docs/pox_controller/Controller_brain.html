<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8"> <!-- Sets character encoding to UTF-8 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Ensures responsive design -->
    <title>Smartville Documentation</title> <!-- Title displayed in the browser tab -->
    
    <!-- Link to an external CSS file for styling -->
    <link rel="stylesheet" href="../style.css">
    <!-- Link to an external JavaScript file that loads after HTML content -->
    <script src="../script.js" defer></script>
</head>

<body>

    <!-- Sidebar for navigation -->
    <div class="sidebar">
        <!-- Navigation links to various documentation sections -->
        <a href="../main_content/Intro.html">Introduction</a>
        <a href="../main_content/Installation.html">Installation</a>
        <a href="../main_content/Usage.html">Usage</a>
        <a href="../main_content/Background.html">Background</a>
        <a href="../main_content/Docker.html">Docker Containers</a>
        <a href="../main_content/platform.html">Grafana, Kafka, Prometheus</a>
        <a href="../main_content/PN.html">Prototypical Networks</a>
        <a href="../main_content/License.html">License</a>
        <a href="../main_content/Citation.html">Citation</a>
        
        <!-- Link to toggle visibility of subcategories under 'Code' -->
        <a href="javascript:void(0)" onclick="toggleSubcategories()">Code</a>
        
        <!-- Subcategories for 'Code', initially hidden -->
        <div id="codeSubcategories" style="display:none;">
            <!-- Subcategory for 'pox_controller' -->
            <div id="pox_controller" class="subcategory">
                <!-- Link to toggle visibility of 'pox_controller' subcategories -->
                <a href="javascript:void(0)" onclick="togglePoxControllerSubcategories()" style="padding-left:20px;">pox_controller</a>
                
                <!-- Subcategories within 'pox_controller' -->
                <div id="poxControllerSubcategories" style="display:none;">
                    <div id="neural_models" class="subcategory">
                        <a href="../pox_controller/Neural_models.html" style="padding-left:40px;">Neural Models</a>
                    </div>
                    <div id="controller_brain" class="subcategory">
                        <a href="../pox_controller/Controller_brain.html" style="padding-left:40px;">Controller Brain</a>
                    </div>
                    <div id="graph_generator" class="subcategory">
                        <a href="../pox_controller/Graph_generator.html" style="padding-left:40px;">Graph Generator</a>
                    </div>
                    <div id="consumer_thread" class="subcategory">
                        <a href="../pox_controller/Consumer_thread.html" style="padding-left:40px;">Consumer Thread</a>
                    </div>
                    <div id="smart_controller" class="subcategory">
                        <a href="../pox_controller/Smart_controller.html" style="padding-left:40px;">Smart Controller</a>
                    </div>
                    <div id="ai" class="subcategory">
                        <a href="../pox_controller/ai.html" style="padding-left:40px;">Ai</a>
                    </div>
                    <div id="curricula" class="subcategory">
                        <a href="../pox_controller/Curricula.html" style="padding-left:40px;">Curricula</a>
                    </div>
                    <div id="dash_generator" class="subcategory">
                        <a href="../pox_controller/Dash_generator.html" style="padding-left:40px;">Dash Generator</a>
                    </div>
                    <div id="arp_entry" class="subcategory">
                        <a href="../pox_controller/Arp_entry.html" style="padding-left:40px;">Arp Entry</a>
                    </div>
                    <div id="flow" class="subcategory">
                        <a href="../pox_controller/Flow.html" style="padding-left:40px;">Flow</a>
                    </div>
                    <div id="flow_logger" class="subcategory">
                        <a href="../pox_controller/Flow_logger.html" style="padding-left:40px;">Flow Logger</a>
                    </div>
                    <div id="grafana_prometheus" class="subcategory">
                        <a href="../pox_controller/Grafana_prometheus.html" style="padding-left:40px;">Grafana-prometheus</a>
                    </div>
                    <div id="metrics_logger" class="subcategory">
                        <a href="../pox_controller/Metrics_logger.html" style="padding-left:40px;">Metrics Logger</a>
                    </div>
                    <div id="replay_buffer" class="subcategory">
                        <a href="../pox_controller/Replay_buffer.html" style="padding-left:40px;">Replay Buffer</a>
                    </div>
                    <div id="prometheus_server" class="subcategory">
                        <a href="../pox_controller/Prometheus_server.html" style="padding-left:40px;">Prometheus Server</a>
                    </div>
                    <div id="wandb_tracker" class="subcategory">
                        <a href="../pox_controller/Wandb_tracker.html" style="padding-left:40px;">Wandb Tracker</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="header">
            <h1><a href="../index.html" style="text-decoration: none;">Smartville</h1></a>
            <p>This is the official SmartVille repository</p>
            <p>Smartville is an open-source testbed based on GNS3, Pytorch, and Docker for training and testing online
                intrusion detection systems based on machine learning.</p>
            <p>Feel free to contribute!</p>
            <p>The related paper <em>"SmartVille: an open-source SDN online-intrusion detection testbed"</em> is under
                review. Stay tuned!</p>
        </div>
        
        <div id="controller_brain" class="content">
            <h2>Controller Brain</h2>
            <p>This file defines the <code>ControllerBrain</code> class, which orchestrates the operations for training
                and evaluating machine learning models in the Smartville project. It integrates various neural modules
                for classification, manages replay buffers for experience learning, and tracks performance metrics using
                the WandB tracking service.</p>

            <h3>Class: ControllerBrain</h3>
            <p>The <code>ControllerBrain</code> class is the core component responsible for handling the flow of data,
                managing model training and evaluation, and interfacing with Grafana and Prometheus for visualization.
            </p>
            <pre><code>
    class ControllerBrain:
        def __init__(self,
                     eval,
                     use_packet_feats,
                     use_node_feats,
                     flow_feat_dim,
                     packet_feat_dim,
                     h_dim,
                     dropout,
                     multi_class,
                     k_shot,
                     replay_buffer_batch_size,
                     kernel_regression,
                     device='cpu',
                     seed=777,
                     debug=False,
                     wb_track=False,
                     wb_project_name='',
                     wb_run_name='',
                     **wb_config_dict):
            ...
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>__init__(self, eval, use_packet_feats, use_node_feats, flow_feat_dim, packet_feat_dim, h_dim, dropout, multi_class, k_shot, replay_buffer_batch_size, kernel_regression, device='cpu', seed=777, debug=False, wb_track=False, wb_project_name='', wb_run_name='', **wb_config_dict)</code>:
                    Initializes the controller with various configuration parameters.</li>
            </ul>

            <h3>Method: add_replay_buffer</h3>
            <p>This method adds a new replay buffer to the ControllerBrain instance for a specific class.</p>
            <pre><code>
    def add_replay_buffer(self, class_name):
        self.inference_allowed = False
        self.experience_learning_allowed = False
        self.eval_allowed = False
        if self.AI_DEBUG:
            self.logger_instance.info(f'Adding a replay buffer with code {self.current_known_classes_count-1}')
            self.logger_instance.info(f'Encoder state mapping: {self.encoder.get_mapping()}')
        
        if not 'G2' in class_name:
            self.replay_buffers[self.current_known_classes_count-1] = ReplayBuffer(
                capacity=REPLAY_BUFFER_MAX_CAPACITY,
                batch_size=self.replay_buff_batch_size,
                seed=self.seed)
        if not 'G1' in class_name:
            self.test_replay_buffers[self.current_known_classes_count-1] = ReplayBuffer(
                        capacity=REPLAY_BUFFER_MAX_CAPACITY,
                        batch_size=self.replay_buff_batch_size,
                        seed=self.seed)
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>add_replay_buffer(self, class_name)</code>: Adds a replay buffer for a specific class.</li>
            </ul>

            <h3>Method: add_class_to_knowledge_base</h3>
            <p>This method adds a new class to the knowledge base, updating the current known classes count and replay
                buffers.</p>
            <pre><code>
    def add_class_to_knowledge_base(self, new_class):
        if self.AI_DEBUG:
            self.logger_instance.info(f'New class found: {new_class}')
        self.current_known_classes_count += 1
        if not 'G2' in new_class:
            self.current_training_known_classes_count += 1 
        if not 'G1' in new_class:
            self.current_test_known_classes_count += 1
        self.add_replay_buffer(new_class)
        self.reset_train_cms()
        self.reset_test_cms()
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>add_class_to_knowledge_base(self, new_class)</code>: Adds a new class to the knowledge base
                    and initializes the corresponding replay buffers.</li>
            </ul>

            <h3>Method: reset_train_cms</h3>
            <p>This method resets the confusion matrices used for training classification.</p>
            <pre><code>
    def reset_train_cms(self):
        self.training_cs_cm = torch.zeros(
            [self.current_known_classes_count, self.current_known_classes_count],
            device=self.device)
        self.training_os_cm = torch.zeros(
            size=(2, 2),
            device=self.device)
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>reset_train_cms(self)</code>: Resets the training confusion matrices.</li>
            </ul>

            <h3>Method: reset_test_cms</h3>
            <p>This method resets the confusion matrices used for testing classification.</p>
            <pre><code>
    def reset_test_cms(self):
        self.eval_cs_cm = torch.zeros(
            [self.current_known_classes_count, self.current_known_classes_count],
            device=self.device)
        self.eval_os_cm = torch.zeros(
            size=(2, 2),
            device=self.device)
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>reset_test_cms(self)</code>: Resets the testing confusion matrices.</li>
            </ul>

            <h3>Method: init_neural_modules</h3>
            <p>This method initializes the neural modules required for the classification tasks, such as the confidence
                decoder and the classifier models.</p>
            <pre><code>
    def init_neural_modules(self, lr, seed):
        torch.manual_seed(seed)
        self.confidence_decoder = ConfidenceDecoder(device=self.device)
        self.os_criterion = nn.BCEWithLogitsLoss().to(self.device)
        self.cs_criterion = nn.CrossEntropyLoss().to(self.device)
        self.kr_criterion = KernelRegressionLoss(repulsive_weigth=REPULSIVE_WEIGHT, 
            attractive_weigth=ATTRACTIVE_WEIGHT).to(self.device)
        ...
        self.check_pretrained()
        ...
        if self.eval:
            self.classifier.eval()
            self.confidence_decoder.eval()
            self.logger_instance.info(f"Using MODULES in EVAL mode!")
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>init_neural_modules(self, lr, seed)</code>: Initializes the neural network modules used in the
                    controller.</li>
            </ul>

            <h3>Method: check_pretrained</h3>
            <p>This method checks if there are pretrained models available and loads them if they exist.</p>
            <pre><code>
    def check_pretrained(self):
        if self.use_packet_feats:
            if self.use_node_feats:
                self.classifier_path = PRETRAINED_MODELS_DIR+'multiclass_flow_packet_node_classifier_pretrained'
                self.confidence_decoder_path = PRETRAINED_MODELS_DIR+'flow_packet_node_confidence_decoder_pretrained'
            else:
                self.classifier_path = PRETRAINED_MODELS_DIR+'multiclass_flow_packet_classifier_pretrained'
                self.confidence_decoder_path = PRETRAINED_MODELS_DIR+'flow_packet_confidence_decoder_pretrained'
        else:
            if self.use_node_feats:
                self.classifier_path = PRETRAINED_MODELS_DIR+'multiclass_flow_node_classifier_pretrained'
                self.confidence_decoder_path = PRETRAINED_MODELS_DIR+'flow_node_confidence_decoder_pretrained'
            else:    
                self.classifier_path = PRETRAINED_MODELS_DIR+'multiclass_flow_classifier_pretrained'
                self.confidence_decoder_path = PRETRAINED_MODELS_DIR+'flow_confidence_decoder_pretrained'
    
        if os.path.exists(PRETRAINED_MODELS_DIR):
            ...
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>check_pretrained(self)</code>: Checks and loads pretrained models if available.</li>
            </ul>

            <h3>Method: infer</h3>
            <p>This method performs inference on a batch of input data using the initialized neural models.</p>
            <pre><code>
    def infer(self, flow_input_batch, packet_input_batch, node_feat_input_batch, batch_labels, query_mask):
        if self.use_packet_feats:
            if self.use_node_feats:
                logits, hiddens, predicted_kernel = self.classifier(
                    flow_input_batch, 
                    packet_input_batch, 
                    node_feat_input_batch,
                    batch_labels, 
                    self.current_known_classes_count,
                    query_mask)
            ...
        return logits, hiddens, predicted_kernel
        </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>infer(self, flow_input_batch, packet_input_batch, node_feat_input_batch, batch_labels, query_mask)</code>:
                    Runs inference on the input batch and returns the logits, hidden vectors, and predicted kernel.</li>
            </ul>

            <h3>Method: experience_learning</h3>
            <p>This method performs experience learning by sampling from replay buffers and updating the model based on
                the training data.</p>
            <pre><code>
    def experience_learning(self):
        balanced_flow_batch, \
            balanced_packet_batch, \
                balanced_node_feat_batch, \
                    balanced_labels, \
                        balanced_zda_labels, \                        balanced_test_zda_labels = self.sample_from_replay_buffers(
                            samples_per_class=self.replay_buff_batch_size,
                            mode=TRAINING)
    
    query_mask = self.get_canonical_query_mask(TRAINING)
    assert query_mask.shape[0] == balanced_labels.shape[0]

    logits, hidden_vectors, predicted_kernel = self.infer(
        flow_input_batch=balanced_flow_batch,
        packet_input_batch=balanced_packet_batch,
        node_feat_input_batch=balanced_node_feat_batch,
        batch_labels=balanced_labels,
        query_mask=query_mask)

    loss = 0

    one_hot_labels = self.get_oh_labels(
        curr_shape=(balanced_labels.shape[0], logits.shape[1]), 
        targets=balanced_labels)

    known_oh_labels = one_hot_labels[~balanced_zda_labels.squeeze(1).bool()]
    known_class_h_mask = known_oh_labels.sum(0) > 0

    kr_loss, predicted_clusters, _ = self.kernel_regression_step(
        predicted_kernel, 
        one_hot_labels, 
        TRAINING)

    if REGULARIZATION:
        loss += kr_loss

    if self.multi_class:
        ad_loss, _ = self.AD_step(
            zda_labels=balanced_zda_labels, 
            preds=logits[:, known_class_h_mask], 
            query_mask=query_mask,
            mode=TRAINING)
        loss += ad_loss

    self.training_cs_cm += efficient_cm(
        preds=logits.detach(),
        targets_onehot=one_hot_labels[query_mask])

    if self.backprop_counter % REPORT_STEP_FREQUENCY == 0:
        self.report(
            preds=logits[:, known_class_h_mask],  
            hiddens=hidden_vectors.detach(), 
            labels=balanced_labels,
            predicted_clusters=predicted_clusters, 
            query_mask=query_mask,
            phase=TRAINING)

        if self.eval_allowed:
            self.evaluate_models()

    cs_acc = self.learning_step(balanced_labels, logits, TRAINING, query_mask, loss)
    
    if self.AI_DEBUG: 
        self.logger_instance.info(f'{TRAINING} batch labels mean: {balanced_labels.to(torch.float16).mean().item()} '+\
                                  f'{TRAINING} batch prediction mean: {logits.max(1)[1].to(torch.float32).mean()}')
        self.logger_instance.info(f'{TRAINING} mean multiclass classif accuracy: {cs_acc}')
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>experience_learning(self)</code>: Samples from replay buffers, performs learning steps, and
                    updates the model.</li>
            </ul>

            <h3>Method: evaluate_models</h3>
            <p>This method evaluates the models by running inference on samples from replay buffers, and calculates
                evaluation metrics.</p>
            <pre><code>
def evaluate_models(self):
    self.classifier.eval()
    self.confidence_decoder.eval()
    
    mean_eval_ad_acc = 0
    mean_eval_cs_acc = 0
    mean_eval_kr_ari = 0

    for _ in range(EVALUATION_ROUNDS):
        balanced_flow_batch, \
            balanced_packet_batch, \
                balanced_node_feat_batch, \
                    balanced_labels, \
                        balanced_zda_labels, \
                            balanced_test_zda_labels = self.sample_from_replay_buffers(
                                samples_per_class=self.replay_buff_batch_size,
                                mode=INFERENCE)
        
        query_mask = self.get_canonical_query_mask(INFERENCE)
        assert query_mask.shape[0] == balanced_labels.shape[0]

        logits, hidden_vectors, predicted_kernel = self.infer(
            flow_input_batch=balanced_flow_batch,
            packet_input_batch=balanced_packet_batch,
            node_feat_input_batch=balanced_node_feat_batch,
            batch_labels=balanced_labels,
            query_mask=query_mask)

        one_hot_labels = self.get_oh_labels(
            curr_shape=(balanced_labels.shape[0], logits.shape[1]), 
            targets=balanced_labels)
        
        known_oh_labels = one_hot_labels[~balanced_zda_labels.squeeze(1).bool()]
        known_class_h_mask = known_oh_labels.sum(0) > 0

        _, predicted_clusters, kr_precision = self.kernel_regression_step(
            predicted_kernel, 
            one_hot_labels,
            INFERENCE)

        _, ad_acc = self.AD_step(
            zda_labels=balanced_zda_labels, 
            preds=logits[:, known_class_h_mask], 
            query_mask=query_mask,
            mode=INFERENCE)

        self.eval_cs_cm += efficient_cm(
            preds=logits.detach(),
            targets_onehot=one_hot_labels[query_mask])
        
        cs_acc = self.learning_step(balanced_labels, logits, INFERENCE, query_mask)

        mean_eval_ad_acc += (ad_acc / EVALUATION_ROUNDS)
        mean_eval_cs_acc += (cs_acc / EVALUATION_ROUNDS)
        mean_eval_kr_ari += (kr_precision / EVALUATION_ROUNDS)

    if self.AI_DEBUG: 
        self.logger_instance.info(f'{INFERENCE} mean eval AD accuracy: {mean_eval_ad_acc.item()} '+\
                                f'{INFERENCE} mean eval CS accuracy: {mean_eval_cs_acc.item()}')
        self.logger_instance.info(f'{INFERENCE} mean eval KR accuracy: {mean_eval_kr_ari}')
    if self.wbt:
        self.wbl.log({'Mean EVAL AD ACC': mean_eval_ad_acc.item(), STEP_LABEL:self.backprop_counter})
        self.wbl.log({'Mean EVAL CS ACC': mean_eval_cs_acc.item(), STEP_LABEL:self.backprop_counter})
        self.wbl.log({'Mean EVAL KR PREC': mean_eval_kr_ari, STEP_LABEL:self.backprop_counter})

    if not self.eval:
        self.check_kr_progress(curr_kr_acc=mean_eval_kr_ari)
        self.check_cs_progress(curr_cs_acc=mean_eval_cs_acc.item())
        self.check_AD_progress(curr_ad_acc=mean_eval_ad_acc.item())

    self.report(
            preds=logits[:, known_class_h_mask], 
            hiddens=hidden_vectors.detach(), 
            labels=balanced_labels,
            predicted_clusters=predicted_clusters, 
            query_mask=query_mask,
            phase=INFERENCE)

    self.classifier.train()
    self.confidence_decoder.train()
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>evaluate_models(self)</code>: Evaluates the models on test data, updates metrics, and adjusts
                    training if necessary.</li>
            </ul>

            <h3>Method: report</h3>
            <p>This method generates reports, including confusion matrices and latent space visualizations, and logs
                them to WandB.</p>
            <pre><code>
def report(self, preds, hiddens, labels, predicted_clusters, query_mask, phase):
    if phase == TRAINING:
        cs_cm_to_plot = self.training_cs_cm
        os_cm_to_plot = self.training_os_cm
    elif phase == INFERENCE:
        cs_cm_to_plot = self.eval_cs_cm
        os_cm_to_plot = self.eval_os_cm

    if self.wbt:
        self.plot_confusion_matrix(
            mod=CLOSED_SET,
            cm=cs_cm_to_plot,
            phase=phase,
            norm=False,
            classes=self.encoder.get_labels())
        self.plot_confusion_matrix(
            mod=ANOMALY_DETECTION,
            cm=os_cm_to_plot,
            phase=phase,
            norm=False,
            classes=['Known', 'ZdA'])
        self.plot_hidden_space(hiddens=hiddens, labels=labels, predicted_labels=predicted_clusters, phase=phase)
        self.plot_scores_vectors(score_vectors=preds, labels=labels[query_mask], phase=phase)

    if self.AI_DEBUG:
        self.logger_instance.info(f'{phase} CS Conf matrix: \n {cs_cm_to_plot}')
        self.logger_instance.info(f'{phase} AD Conf matrix: \n {os_cm_to_plot}')
    
    if phase == TRAINING:
        self.reset_train_cms()
    elif phase == INFERENCE:
        self.reset_test_cms()
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>report(self, preds, hiddens, labels, predicted_clusters, query_mask, phase)</code>: Generates
                    and logs various reports, including confusion matrices and visualizations of hidden spaces.</li>
            </ul>

            <h3>Method: save_models</h3>
            <p>This method saves the models' state dictionaries to files.</p>
            <pre><code>
def save_models(self):
    self.save_cs_model(postfix='coupled')
    if self.multi_class:
        self.save_ad_model(postfix='coupled')
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>save_models(self)</code>: Saves the state dictionaries of the models to files.</li>
            </ul>

            <h3>Method: learning_step</h3>
            <p>This method performs a single learning step, including loss calculation, backpropagation, and
                optimization.</p>
            <pre><code>
def learning_step(self, labels, predictions, mode, query_mask, prev_loss=0):
    cs_loss = self.cs_criterion(input=predictions,
                                target=labels[query_mask].squeeze(1))

    if mode == TRAINING:
        loss = prev_loss + cs_loss
        # backward pass
        self.cs_optimizer.zero_grad()
        loss.backward()
        # update weights
        self.cs_optimizer.step()

    # compute accuracy
    acc = self.get_accuracy(logits_preds=predictions, decimal_labels=labels, query_mask=query_mask)

    # report progress
    if self.wbt:
        self.wbl.log({mode+'_'+CS_ACC: acc.item(), STEP_LABEL:self.backprop_counter})
        self.wbl.log({mode+'_'+CS_LOSS: cs_loss.item(), STEP_LABEL:self.backprop_counter})

    return acc
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>learning_step(self, labels, predictions, mode, query_mask, prev_loss=0)</code>: Performs a
                    learning step, including backpropagation and logging.</li>
            </ul>

            <h3>Method: get_accuracy</h3>
            <p>This method calculates the accuracy of predictions against the ground truth labels.</p>
            <pre><code>
def get_accuracy(self, logits_preds, decimal_labels, query_mask):
    match_mask = logits_preds.max(1)[1] == decimal_labels.max(1)[0][query_mask]
    return match_mask.sum() / match_mask.shape[0]
    </code></pre>
            <p><strong>Methods:</strong></p>
            <ul>
                <li><code>get_accuracy(self, logits_preds, decimal_labels, query_mask)</code>: Computes the accuracy of
                    the model predictions.</li>
            </ul>
        </div>
    </body>

    </html>